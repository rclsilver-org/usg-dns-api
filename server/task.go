package server

import (
	"bytes"
	"context"
	"fmt"
	"net"
	"os"
	"os/exec"
	"sort"
	"strings"

	"github.com/sirupsen/logrus"

	"github.com/rclsilver-org/usg-dns-api/pkg/utils"
	"github.com/rclsilver-org/usg-dns-api/unifi"
)

func (s *Server) writeHostsFile(ctx context.Context, manual bool) error {
	logrus.WithContext(ctx).Debugf("starting to write the hosts file (manual: %v)", manual)

	if err := s.unifi.Login(ctx); err != nil {
		return fmt.Errorf("unable to login to the unifi-controller API: %w", err)
	}

	// build the networks map
	networks, err := s.unifi.GetNetworks(ctx)
	if err != nil {
		return fmt.Errorf("unable to fetch the networks list: %w", err)
	}
	networksMap := map[*net.IPNet]unifi.NetworkConf{}
	for _, network := range networks {
		if !network.Enabled {
			continue
		}
		networksMap[network.IpSubnet] = network
	}

	// build the client map
	clients, err := s.unifi.GetUsers(ctx)
	if err != nil {
		return fmt.Errorf("unable to fetch the clients list: %w", err)
	}
	fixedIPs := []unifi.User{}
	for _, client := range clients {
		if client.UseFixedIP {
			fixedIPs = append(fixedIPs, client)
		}
	}

	type result struct {
		HostName string
		Aliases  []string
		Reverse  string
	}

	// init the result with the fixed IP addresses
	results := map[string]*result{}
	for _, client := range fixedIPs {
		ipBytes := client.FixedIP.To4()
		name := client.Name
		if name == "" {
			name = client.HostName
		}

		result := result{
			HostName: name,
			Reverse:  fmt.Sprintf("%d.%d.%d.%d.in-addr.arpa", ipBytes[3], ipBytes[2], ipBytes[1], ipBytes[0]),
		}

		for cidr, net := range networksMap {
			if net.DomainName != "" && cidr.Contains(client.FixedIP) {
				result.Aliases = append(result.Aliases, result.HostName)
				result.HostName += "." + net.DomainName
			}
		}

		results[client.FixedIP.String()] = &result
	}

	// update the result with the records from the database
	records := s.db.GetRecords()
	for _, record := range records {
		if _, ok := results[record.Target]; ok {
			results[record.Target].Aliases = append(results[record.Target].Aliases, record.Name)
		} else {
			ipParts := strings.Split(record.Target, ".")

			results[record.Target] = &result{
				HostName: record.Name,
				Reverse:  fmt.Sprintf("%s.%s.%s.%s.in-addr.arpa", ipParts[3], ipParts[2], ipParts[1], ipParts[0]),
			}
		}
	}

	// build the buffer
	keys := make([]string, 0, len(results))
	for ip := range results {
		keys = append(keys, ip)
	}
	keys, err = sortIPv4Addresses(keys)
	if err != nil {
		return fmt.Errorf("unable to sort IPv4 addresses: %w", err)
	}

	buffer := bytes.NewBuffer(nil)
	buffer.WriteString("# File generated by the usg-dns-api\n")
	buffer.WriteString("# Do not manually edit\n")
	buffer.WriteString("\n")

	for _, ip := range keys {
		buffer.WriteString(fmt.Sprintf("%s\t%s", ip, results[ip].HostName))
		for _, alias := range results[ip].Aliases {
			buffer.WriteString(fmt.Sprintf(" %s", alias))
		}
		buffer.WriteString(fmt.Sprintf(" %s\n", results[ip].Reverse))
	}

	fileHash, err := utils.FileHash(s.cfg.HostsFile)
	if err != nil {
		if !os.IsNotExist(err) {
			return fmt.Errorf("unable to compute the hash of the %s file: %w", s.cfg.HostsFile, err)
		}
	} else {
		if utils.BytesHash(buffer.Bytes()) == fileHash {
			logrus.WithContext(ctx).Debugf("no changed detected, skipping the hosts file generation")

			return nil
		}
	}

	if err := os.WriteFile(s.cfg.HostsFile, buffer.Bytes(), 0644); err != nil {
		return fmt.Errorf("unable to write the hosts file: %w", err)
	}
	logrus.WithContext(ctx).Infof("new version of the hosts file written in %s", s.cfg.HostsFile)

	cmd := exec.Command("pkill", "-HUP", "dnsmasq")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("error while restarting dnsmasq: %w", err)
	}
	logrus.WithContext(ctx).Info("dnsmasq has been restarted")

	return nil
}

func sortIPv4Addresses(ips []string) ([]string, error) {
	// Convertir les adresses IPv4 en net.IP pour comparaison
	parsedIPs := make([]net.IP, len(ips))
	for i, ipStr := range ips {
		ip := net.ParseIP(ipStr).To4() // Utilise To4 pour s'assurer qu'on a bien une IPv4
		if ip == nil {
			return nil, fmt.Errorf("invalid IPv4 address: %s", ipStr)
		}
		parsedIPs[i] = ip
	}

	// Trier les adresses IPv4 en utilisant sort.Slice
	sort.Slice(parsedIPs, func(i, j int) bool {
		return bytes.Compare(parsedIPs[i], parsedIPs[j]) < 0
	})

	// Convertir les net.IP triés en chaînes
	sortedIPs := make([]string, len(parsedIPs))
	for i, ip := range parsedIPs {
		sortedIPs[i] = ip.String()
	}

	return sortedIPs, nil
}
